{
	"title": "连续子串的最大值(经典的DP问题)",
    "alias": "dp-algorithm-problem",
    "summary": "【问题描述】  在长度为N的整形数组中，求连续子串的和的最大值，要求复杂度为O(N)。 例如：1 2 3 -1 -20 100 34，结果为134。",
    "content": "###【问题描述】 \n在长度为N的整形数组中，求连续子串的和的最大值，要求复杂度为O(N)。\n例如：1 2 3 -1 -20 100 34，结果为134。\n###【分析】 \n####思路 \n一网友的几种解决方法：\n\n    #include<iostream>  \n    using namespace std;  \n    #define NUM 10  \n    template<class ElemType>  \n    //普通2层循环时间复杂度 O(n*n)  \n    void MaxSum(ElemType*p,int& beg,int& end,int& sum)  \n    {  \n        ElemType count=0;  \n        sum=count;  \n        for(int i=0;i<NUM-1;i++)  \n        {  \n            count=0;  \n            for(int j=i;j<=NUM-1;j++)  \n            {  \n                count+=p[j];  \n                if (count>sum)   \n                {  \n                    beg=i;  \n                    end=j;  \n                    sum=count;  \n                }  \n            }  \n        }  \n    }  \n    //利用分治算法时间复杂度O(n)  \n    template<class ElemType>  \n    void MaxSum1(ElemType*p,int low,int high,int& beg,int& end,ElemType& sum)  \n    {  \n        if(low==high)  \n        {  \n            sum=(p[low]>0)?p[low]:0;  \n        }  \n        else  \n        {  \n            int i;  \n            int mid=(low+high)/2;  \n            int leftStart,leftEnd; //左边区间最大子段的起止位置  \n            int rightStart,rightEnd; //右边区间最大子段的起止位置  \n            int leftSum=0; //左边区间的最大和  \n            int rightSum=0; //右边区间的最大和  \n            MaxSum1(p,low,mid,leftStart,leftEnd,leftSum);  \n            MaxSum1(p,mid+1,high,rightStart,rightEnd,rightSum);  \n            ElemType sumL=0; //跨越左右区间的左边部分的最大子段和  \n            ElemType curSum=0; //当前跨越左右区间的左边区间部分的子段和  \n            for(i=mid;i>=low;i--)  \n            { //处理左边区间  \n                curSum+=p[i];  \n                if (sumL<curSum)  \n                { //修改最大字段和和开始位置  \n                    sumL=curSum;  \n                    beg=i;  \n                }  \n            }  \n            ElemType sumR=0; //跨越左右区间的右边部分的最大子段和  \n            ElemType curSum1=0; //当前跨越左右区间的右边区间部分的子段和  \n            for(i=mid+1;i<=high;i++)  \n            { //处理右边区间  \n                curSum1+=p[i];  \n                if (sumR<curSum1)  \n                { //修改最大字段和和开始位置  \n                    sumR=curSum1;  \n                    end=i;  \n                }  \n            }  \n            sum=sumL+sumR; //跨越左右区间的最大字段和  \n            if (sum<=leftSum)   \n            {  \n                sum=leftSum;  \n                beg=leftStart;  \n                end=leftEnd;  \n            }  \n            if (sum<=rightSum)   \n            {  \n                sum=rightSum;  \n                beg=rightStart;  \n                end=rightEnd;  \n            }  \n        }  \n    }  \n    //利用动态规划时间复杂度也为O(n)  \n    template<class ElemType>  \n    void MaxSum2(ElemType*p,int& beg,int& end,ElemType& sum)  \n    {  \n        sum=0;  \n        ElemType b=0; //上界为j的最大字段和  \n        int bStart,bEnd; //上界为j的最大字符段和的起止位置  \n        for(int j=0;j<NUM;j++)  \n        { //循环求最大字段和  \n            if (b>0)   \n            {  \n                b+=p[j];  \n                bEnd=j;  \n            }  \n            else  \n            {  \n                b=p[j];  \n                bStart=j;  \n                bEnd=j;  \n            }  \n            if (b>sum) //判断当前子段和，之前最大子段和的大小  \n            {  \n                sum=b;  \n                beg=bStart;  \n                end=bEnd;  \n            }  \n        }  \n    }  \n    void main()  \n    {  \n        int p[NUM]={-4,2,4,2,-2,8,9,-4,3,-2};  \n        int beg,end,sum;  \n        beg=end=sum=0;  \n        // MaxSum<int>(p,beg,end,sum);  \n        // MaxSum1<int>(p,0,NUM-1,beg,end,sum);  \n        MaxSum2<int>(p,beg,end,sum);  \n        cout<<\"开始下标为:\"<<beg<<endl;  \n        cout<<\"结束下标为:\"<<end<<endl;  \n        cout<<\"最大字段和为:\"<<sum<<endl;  \n    }",
    "source": "",
    "url": "",
    "user": {
        "username": "Icyse"
    },
    "imgList": [],
    "categoryList": ["Algorithm"],
    "commentList": [],
    "viewCount": 0,
    "commentCount": 0,
    "voteCount": 0,
    "createdTime": "2016-01-01 10:00",
    "updatedTime": "2016-01-01 10:00"
}